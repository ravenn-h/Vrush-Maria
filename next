Excellente question ! Oui, **chaque sous-session nÃ©cessite son propre pairing code** car chaque session = un numÃ©ro WhatsApp diffÃ©rent.

Voici le code modifiÃ© pour que :
1. âœ… Seul le bot principal dÃ©marre automatiquement
2. âœ… Les sous-bots se crÃ©ent uniquement via commande aprÃ¨s dÃ©ploiement
3. âœ… Commande `addsession` pour ajouter un sous-bot
4. âœ… Commande `pair` pour obtenir le pairing code d'un sous-bot

## ğŸ“ Code modifiÃ©

### 1. **index.js - Version Multi-Session AmÃ©liorÃ©e**

```javascript
console.clear();
console.log("Â© Vrush Maria v2 - Multi Session by Raven-Hisoka");
require("./config");

const {
  default: makeWASocket,
  useMultiFileAuthState,
  DisconnectReason,
  makeCacheableSignalKeyStore
} = require('@whiskeysockets/baileys');

const fs = require('fs');
const pino = require('pino');
const cfonts = require("cfonts");

// Stocker toutes les instances de bots
const activeBots = new Map();
const pendingPairings = new Map(); // Sessions en attente de pairing

// Affichage du banner
cfonts.say("Vrush Maria v2", {
  font: "block",
  align: "left",
  colors: ["#ff00ff", "white"],
  background: "transparent",
  rawMode: false
});

// Configuration - Seul le bot principal dÃ©marre automatiquement
const MAIN_SESSION = {
  id: "main",
  name: "Main Bot",
  sessionPath: "./sessions/main",
  isActive: true
};

// Fonction pour crÃ©er les dossiers de sessions
function ensureSessionDir(sessionPath) {
  if (!fs.existsSync('./sessions')) {
    fs.mkdirSync('./sessions');
  }
  if (!fs.existsSync(sessionPath)) {
    fs.mkdirSync(sessionPath, { recursive: true });
  }
}

// Fonction principale pour dÃ©marrer une session
async function startSession(sessionId, sessionName, sessionPath, phoneNumber = null) {
  console.log(`\nğŸš€ Starting ${sessionName} (${sessionId})...`);
  
  try {
    ensureSessionDir(sessionPath);
    
    const { state, saveCreds } = await useMultiFileAuthState(sessionPath);
    
    const socket = makeWASocket({
      printQRInTerminal: false,
      syncFullHistory: true,
      markOnlineOnConnect: true,
      connectTimeoutMs: 60000,
      defaultQueryTimeoutMs: 0,
      keepAliveIntervalMs: 10000,
      generateHighQualityLinkPreview: true,
      
      patchMessageBeforeSending: (message) => {
        const requiresPatch = !!(message.buttonsMessage || message.templateMessage || message.listMessage);
        if (requiresPatch) {
          message = {
            viewOnceMessage: {
              message: {
                messageContextInfo: {
                  deviceListMetadataVersion: 2,
                  deviceListMetadata: {}
                },
                ...message
              }
            }
          };
        }
        return message;
      },
      
      version: [4, 0, 0],
      browser: ["Ubuntu", "Chrome", "20.0.04"],
      logger: pino({ level: 'fatal' }),
      auth: {
        creds: state.creds,
        keys: makeCacheableSignalKeyStore(
          state.keys, 
          pino().child({ level: 'silent', stream: "store" })
        )
      }
    });

    // MÃ©tadonnÃ©es de la session
    socket.sessionId = sessionId;
    socket.sessionName = sessionName;
    socket.sessionPath = sessionPath;

    // Gestion du pairing pour nouvelles sessions
    if (!socket.authState.creds.registered) {
      console.log(`â³ ${sessionName} waiting for pairing...`);
      
      // Si c'est le bot principal, demander le numÃ©ro maintenant
      if (sessionId === 'main') {
        const readline = require('readline');
        const rl = readline.createInterface({
          input: process.stdin,
          output: process.stdout
        });
        
        phoneNumber = await new Promise(resolve => {
          rl.question(`\nğŸ“± Enter phone number for Main Bot: `, resolve);
        });
        rl.close();
      }
      
      // Si un numÃ©ro est fourni, gÃ©nÃ©rer le pairing code
      if (phoneNumber) {
        const pairingCode = await socket.requestPairingCode(phoneNumber);
        console.log(`\nâœ… Pairing Code for ${sessionName}: ${pairingCode}\n`);
        
        // Stocker dans les pairings en attente
        pendingPairings.set(sessionId, {
          code: pairingCode,
          phone: phoneNumber,
          timestamp: Date.now(),
          socket: socket
        });
      } else {
        // Stocker la socket en attente de pairing
        pendingPairings.set(sessionId, {
          socket: socket,
          timestamp: Date.now()
        });
      }
    }

    // DÃ©coder les JIDs
    socket.decodeJid = (jid) => {
      if (!jid) return jid;
      if (/:\d+@/gi.test(jid)) {
        const { jidDecode } = require('@whiskeysockets/baileys');
        let decoded = jidDecode(jid) || {};
        return decoded.user && decoded.server && decoded.user + '@' + decoded.server || jid;
      }
      return jid;
    };

    // Gestion des messages
    socket.ev.on('messages.upsert', async (chatUpdate) => {
      try {
        const message = chatUpdate.messages[0];
        if (!message.message) return;
        
        message.message = Object.keys(message.message)[0] === 'ephemeralMessage' 
          ? message.message.ephemeralMessage.message 
          : message.message;
        
        if (message.key && message.key.remoteJid === 'status@broadcast') return;
        if (message.key.id.startsWith("BAE5") && message.key.id.length === 16) return;
        if (message.key.id.startsWith("FatihArridho_")) return;
        
        // Passer les infos de session au handler
        const { smsg } = require('./lib/myfunction');
        const formattedMessage = smsg(socket, message, null);
        formattedMessage.sessionId = sessionId;
        formattedMessage.sessionName = sessionName;
        formattedMessage.isMainBot = sessionId === 'main';
        
        require('./Hisoka.js')(socket, formattedMessage, chatUpdate, null);
      } catch (error) {
        console.log(`Error in ${sessionName}:`, error);
      }
    });

    // Mise Ã  jour des contacts
    socket.ev.on("contacts.update", (update) => {
      for (let contact of update) {
        let id = socket.decodeJid(contact.id);
        // Store contact info if needed
      }
    });

    // Gestion de la connexion
    socket.ev.on('connection.update', async (update) => {
      const { connection, lastDisconnect } = update;
      
      if (connection === "open") {
        console.log(`âœ… ${sessionName} connected successfully!`);
        
        // Retirer des pairings en attente
        pendingPairings.delete(sessionId);
        
        // Ajouter aux bots actifs
        activeBots.set(sessionId, socket);
        
        // Message de bienvenue au owner
        const ownerNumber = global.ownerNumber + '@s.whatsapp.net';
        const welcomeMessage = `ğŸ¤– *${sessionName}* Connected!
        
ğŸ†” Session: \`${sessionId}\`
ğŸ“± Number: ${socket.user.id.split("@")[0]}
â° Time: ${new Date().toLocaleString()}
âœ… Status: Active & Ready

${sessionId === 'main' ? 'ğŸ‘‘ Main Bot' : 'ğŸ”¹ Sub-Bot'}

Type *.menu* to start!`;
        
        try {
          await socket.sendMessage(ownerNumber, { text: welcomeMessage });
        } catch (err) {
          console.log(`Failed to send welcome message for ${sessionName}`);
        }
      }
      
      if (connection === "close") {
        const statusCode = lastDisconnect?.error?.output?.statusCode 
          || lastDisconnect?.error?.statusCode 
          || DisconnectReason.connectionClosed;
        
        if (statusCode !== DisconnectReason.loggedOut) {
          console.log(`ğŸ”„ Reconnecting ${sessionName}...`);
          setTimeout(() => startSession(sessionId, sessionName, sessionPath), 5000);
        } else {
          console.log(`âŒ ${sessionName} logged out.`);
          activeBots.delete(sessionId);
          pendingPairings.delete(sessionId);
        }
      }
    });

    // Ã‰vÃ©nements de groupe
    socket.ev.on('group-participants.update', async (update) => {
      await (await import('./gc.js')).default(socket, update);
    });

    socket.ev.on("creds.update", saveCreds);
    
    socket.public = true;
    
    return socket;
    
  } catch (error) {
    console.error(`âŒ Failed to start ${sessionName}:`, error);
    return null;
  }
}

// Fonction pour gÃ©nÃ©rer un pairing code pour une session existante
async function generatePairingCode(sessionId, phoneNumber) {
  const pending = pendingPairings.get(sessionId);
  
  if (!pending) {
    return { success: false, message: "Session not found in pending pairings" };
  }
  
  try {
    const pairingCode = await pending.socket.requestPairingCode(phoneNumber);
    
    // Mettre Ã  jour les infos
    pendingPairings.set(sessionId, {
      ...pending,
      code: pairingCode,
      phone: phoneNumber,
      timestamp: Date.now()
    });
    
    return { 
      success: true, 
      code: pairingCode,
      phone: phoneNumber,
      sessionId: sessionId
    };
  } catch (error) {
    return { success: false, message: error.message };
  }
}

// Fonction pour crÃ©er une nouvelle session (commande addsession)
async function createNewSession(sessionId, sessionName) {
  // VÃ©rifier si la session existe dÃ©jÃ 
  if (activeBots.has(sessionId) || pendingPairings.has(sessionId)) {
    return { success: false, message: "Session already exists" };
  }
  
  // VÃ©rifier l'ID
  if (!/^[a-z0-9_-]+$/i.test(sessionId)) {
    return { success: false, message: "Invalid session ID. Use only letters, numbers, _ and -" };
  }
  
  const sessionPath = `./sessions/${sessionId}`;
  
  try {
    await startSession(sessionId, sessionName, sessionPath);
    
    return { 
      success: true, 
      message: `Session "${sessionName}" created! Use .pair ${sessionId} <phone> to get pairing code`,
      sessionId: sessionId
    };
  } catch (error) {
    return { success: false, message: error.message };
  }
}

// Fonction pour obtenir le statut de toutes les sessions
function getSessionsStatus() {
  const sessions = {
    active: [],
    pending: []
  };
  
  // Sessions actives
  for (const [sessionId, bot] of activeBots.entries()) {
    sessions.active.push({
      id: sessionId,
      name: bot.sessionName,
      number: bot.user?.id?.split("@")[0],
      connected: true,
      isMain: sessionId === 'main'
    });
  }
  
  // Sessions en attente de pairing
  for (const [sessionId, data] of pendingPairings.entries()) {
    sessions.pending.push({
      id: sessionId,
      name: data.socket?.sessionName || 'Unknown',
      phone: data.phone || 'Not set',
      code: data.code || 'Not generated',
      timestamp: data.timestamp
    });
  }
  
  return sessions;
}

// Fonction pour arrÃªter une session
async function stopSession(sessionId) {
  if (sessionId === 'main') {
    return { success: false, message: "Cannot stop main bot" };
  }
  
  const bot = activeBots.get(sessionId);
  if (bot) {
    try {
      await bot.logout();
      activeBots.delete(sessionId);
      
      // Supprimer le dossier de session
      const sessionPath = `./sessions/${sessionId}`;
      if (fs.existsSync(sessionPath)) {
        fs.rmSync(sessionPath, { recursive: true, force: true });
      }
      
      return { success: true, message: `Session ${sessionId} stopped and removed` };
    } catch (error) {
      return { success: false, message: error.message };
    }
  }
  
  // VÃ©rifier dans les pending
  if (pendingPairings.has(sessionId)) {
    pendingPairings.delete(sessionId);
    const sessionPath = `./sessions/${sessionId}`;
    if (fs.existsSync(sessionPath)) {
      fs.rmSync(sessionPath, { recursive: true, force: true });
    }
    return { success: true, message: `Pending session ${sessionId} removed` };
  }
  
  return { success: false, message: "Session not found" };
}

// Exporter les fonctions
module.exports = {
  startSession,
  createNewSession,
  generatePairingCode,
  stopSession,
  getSessionsStatus,
  activeBots,
  pendingPairings
};

// DÃ©marrer uniquement le bot principal au lancement
async function initialize() {
  console.log("ğŸ¤– Initializing Vrush Maria v2 Multi-Session Bot...\n");
  await startSession(MAIN_SESSION.id, MAIN_SESSION.name, MAIN_SESSION.sessionPath);
  console.log("\nâœ… Main bot started! Use commands to add sub-bots.\n");
}

initialize();

// Auto-reload
let file = require.resolve(__filename);
require('fs').watchFile(file, () => {
  require('fs').unwatchFile(file);
  console.log("\x1b[32m" + __filename + " \x1b[1;32mupdated!\x1b[0m");
  delete require.cache[file];
  require(file);
});
```

### 2. **Commandes dans Hisoka.js**

```javascript
// Dans votre fichier Hisoka.js, ajoutez ces commandes

case 'sessions':
case 'listsessions':
case 'bots': {
  if (!isOwner) return reply('âŒ Owner only!');
  
  const { getSessionsStatus } = require('./index.js');
  const sessions = getSessionsStatus();
  
  let text = 'ğŸ¤– *MULTI-SESSION STATUS*\n\n';
  
  // Sessions actives
  text += 'âœ… *ACTIVE SESSIONS* (' + sessions.active.length + ')\n';
  text += 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n';
  
  if (sessions.active.length > 0) {
    sessions.active.forEach((s, i) => {
      text += `\n${i + 1}. ${s.isMain ? 'ğŸ‘‘' : 'ğŸ”¹'} *${s.name}*\n`;
      text += `   ğŸ†” ID: \`${s.id}\`\n`;
      text += `   ğŸ“± Number: ${s.number}\n`;
      text += `   âœ… Status: Connected\n`;
    });
  } else {
    text += '\nNo active sessions\n';
  }
  
  // Sessions en attente
  text += '\n\nâ³ *PENDING PAIRINGS* (' + sessions.pending.length + ')\n';
  text += 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n';
  
  if (sessions.pending.length > 0) {
    sessions.pending.forEach((s, i) => {
      text += `\n${i + 1}. *${s.name}*\n`;
      text += `   ğŸ†” ID: \`${s.id}\`\n`;
      text += `   ğŸ“± Phone: ${s.phone}\n`;
      text += `   ğŸ”‘ Code: ${s.code}\n`;
      const timeAgo = Math.floor((Date.now() - s.timestamp) / 1000);
      text += `   â±ï¸ Waiting: ${timeAgo}s ago\n`;
    });
  } else {
    text += '\nNo pending sessions\n';
  }
  
  text += '\n\nğŸ“ *COMMANDS*\n';
  text += 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n';
  text += 'â€¢ *.addsession* <id> <name>\n';
  text += 'â€¢ *.pair* <id> <phone>\n';
  text += 'â€¢ *.stopsession* <id>\n';
  
  reply(text);
  break;
}

case 'addsession': {
  if (!isOwner) return reply('âŒ Owner only!');
  
  const { createNewSession } = require('./index.js');
  
  // Format: .addsession sessionid SessionName
  const args = text.split(' ');
  const sessionId = args[0];
  const sessionName = args.slice(1).join(' ');
  
  if (!sessionId || !sessionName) {
    return reply(`âŒ *Invalid format!*

*Usage:*
*.addsession* <session-id> <Session Name>

*Example:*
*.addsession* subbot1 My SubBot 1

*Rules:*
â€¢ Session ID: lowercase, no spaces
â€¢ Session Name: any text`);
  }
  
  reply('â³ Creating new session...');
  
  const result = await createNewSession(sessionId.toLowerCase(), sessionName);
  
  if (result.success) {
    reply(`âœ… *Session Created!*

ğŸ†” ID: \`${result.sessionId}\`
ğŸ“ Name: ${sessionName}

*Next Step:*
Use this command to get pairing code:
*.pair ${result.sessionId} <phone-number>*

*Example:*
*.pair ${result.sessionId} +1234567890*`);
  } else {
    reply(`âŒ *Failed to create session!*\n\nReason: ${result.message}`);
  }
  break;
}

case 'pair':
case 'pairing': {
  if (!isOwner) return reply('âŒ Owner only!');
  
  const { generatePairingCode } = require('./index.js');
  
  // Format: .pair sessionid phoneNumber
  const args = text.split(' ');
  const sessionId = args[0];
  const phoneNumber = args[1];
  
  if (!sessionId || !phoneNumber) {
    return reply(`âŒ *Invalid format!*

*Usage:*
*.pair* <session-id> <phone-number>

*Example:*
*.pair* subbot1 +1234567890

*Note:* Include country code with +`);
  }
  
  reply('â³ Generating pairing code...');
  
  const result = await generatePairingCode(sessionId, phoneNumber);
  
  if (result.success) {
    reply(`âœ… *Pairing Code Generated!*

ğŸ†” Session: \`${result.sessionId}\`
ğŸ“± Phone: ${result.phone}
ğŸ”‘ Code: *${result.code}*

*Instructions:*
1. Open WhatsApp on phone ${result.phone}
2. Go to: Settings > Linked Devices
3. Tap "Link a Device"
4. Choose "Link with phone number"
5. Enter code: *${result.code}*

â° Code expires in 1 minute!`);
  } else {
    reply(`âŒ *Failed to generate pairing code!*\n\nReason: ${result.message}`);
  }
  break;
}

case 'stopsession':
case 'removesession': {
  if (!isOwner) return reply('âŒ Owner only!');
  
  const { stopSession } = require('./index.js');
  
  const sessionId = args[0];
  
  if (!sessionId) {
    return reply(`âŒ *Invalid format!*

*Usage:*
*.stopsession* <session-id>

*Example:*
*.stopsession* subbot1

âš ï¸ This will logout and delete the session!`);
  }
  
  reply('â³ Stopping session...');
  
  const result = await stopSession(sessionId);
  
  if (result.success) {
    reply(`âœ… ${result.message}`);
  } else {
    reply(`âŒ ${result.message}`);
  }
  break;
}
```

### 3. **Exemple d'utilisation complÃ¨te**

```bash
# 1. DÃ©marrer le bot
node index.js
# Le bot principal dÃ©marre et demande le pairing code

# 2. Une fois connectÃ©, crÃ©er un sous-bot
.addsession subbot1 Mon Premier SubBot

# 3. Obtenir le pairing code
.pair subbot1 +225XXXXXXXXX

# 4. Scanner le code sur WhatsApp
# Le bot se connectera automatiquement

# 5. Voir toutes les sessions
.sessions

# 6. Ajouter un autre sous-bot
.addsession subbot2 DeuxiÃ¨me SubBot
.pair subbot2 +33XXXXXXXXX

# 7. Supprimer un sous-bot
.stopsession subbot1
```

### 4. **Avantages de cette approche**

âœ… **SÃ©curisÃ©** : Seul le owner peut crÃ©er des sous-bots  
âœ… **ContrÃ´lÃ©** : Pairing uniquement via commande  
âœ… **Flexible** : Ajout/suppression dynamique aprÃ¨s dÃ©ploiement  
âœ… **OrganisÃ©** : Chaque session dans son dossier  
âœ… **TraÃ§able** : Liste de toutes les sessions actives/en attente  
âœ… **Protection** : Impossible de supprimer le bot principal  

VoilÃ  ! Maintenant vous avez un systÃ¨me complet de multi-session avec pairing contrÃ´lÃ© ! ğŸ‰